* 👋 Hi, I’m liubo
* 👀 I’m interested in harmony
* 🌱 I’m currently learning harmony
* 💞️ I’m looking to collaborate on ...
* 📫 How to reach me ...
* 📇 sssssdsdsdsdsdsdasd
* 🎃 dsdsdsdsdsddfsgdgasd
* 🍺 jyukyuiyuiyuigkasd
* 🍥 fsdfgdsgsdgdgadsa
* ✨ xcvxcvxcvxcvdasdaasd
* 🍰 dazdsxasxsaxsaasdsa
* 🚨 gdfgdshdfhfhygjtyu



# title




## 操作系统



## 进程间通信方式

1. 管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
2. 命名管道 (FIFO)：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
3. 信号量：信号量用于实现进程间的互斥与同步，也可以用在线程上，主要有posix信号量和System V信号量，posix信号量一般用在线程上，System V信号量一般用在进程上，posix信号量的函数一般都在下划线。
4. 消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。(优先级，大小)
5. 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
6. 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生，常见的信号。
7. 套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。





常见信号有哪些？

SIGINT，SIGKILL(不能被捕获)，SIGSTOP(不能被捕获)、SIGTERM(可以被捕获)，SIGSEGV，SIGCHLD，SIGALRM









## 父进程fork后父子进程共享的内容

fork之后，子进程会拷贝父进程的数据空间、堆和栈空间（实际上是采用写时复制技术），二者共享代码段。 所以在子进程中修改全局变量（局部变量，分配在堆上的内存同样也是）后，父进程的相同的全局变量不会改变。

共享fd，以及fd对应的文件表项。

不同进程打开同一个文件





进程的fork与文件描述符的拷贝 进程的所打开文件和在fork后的结构图如下所示，子进程是共享父进程的文件表项。









## linux程序启动过程

当你在 shell 中敲入一个命令要执行时，内核会帮我们创建一个新的进程，它在往这个新进程的进程空间里面加载进可执行程序的代码段和数据段后，也会加载进动态连接器(在Linux里面通常就是 /lib/ld-linux.so 符号链接所指向的那个程序，它本省就是一个动态库)的代码段和数据。在这之后，内核将控制传递给动态链接库里面的代码。动态连接器接下来负责加载该命令应用程序所需要使用的各种动态库。加载完毕，动态连接器才将控制传递给应用程序的main函数。如此，你的应用程序才得以运行。(过程链接表（PLT）,  Global Offset Table（GOT）)

 

## Linux开机流程



Linux 程序的启动过程是一个复杂但有序的过程，主要包括以下几个阶段：

### 加载内核



- 计算机通电后，首先由 BIOS（基本输入输出系统）或 UEFI（统一可扩展固件接口）进行初始化，它们负责进行硬件自检，检查硬件是否正常工作，如 CPU、内存、硬盘等。
- 完成自检后，根据设置的启动顺序，从硬盘、光盘、U 盘等设备中读取引导加载程序（Boot Loader），引导加载程序的主要作用是加载操作系统的内核。
- 内核被加载到内存后，开始初始化，它会进行一系列的操作，如检测硬件设备、初始化内存管理、建立进程调度等。

### 启动系统服务



- 内核初始化完成后，会启动系统的第一个进程，通常是 init 进程或 systemd 进程，init 是 SysVinit 初始化系统的核心进程，而 systemd 是现代 Linux 系统中常用的初始化系统。
- init 进程或 systemd 进程会根据配置文件来启动其它系统服务和进程，如网络服务、文件系统服务、打印服务等。这些服务的启动顺序和依赖关系都在配置文件中有明确规定。
- 系统服务启动完成后，会启动用户登录界面，等待用户输入用户名和密码进行登录。

### 加载用户环境



- 用户输入用户名和密码登录后，系统会根据用户的配置文件来加载用户环境，这些配置文件包括`.bash_profile`、`.bashrc`、`.zshrc`等，它们定义了用户的环境变量、命令别名、终端设置等。
- 根据配置文件中的设置，系统会启动相应的终端模拟器或图形界面环境，如 GNOME、KDE 等。在图形界面环境中，会加载桌面管理器，负责管理桌面的显示、窗口管理、任务栏等。

### 执行应用程序



- 用户在终端或图形界面中输入命令或点击应用程序图标来启动应用程序，系统会根据命令或图标对应的可执行文件路径，找到并加载应用程序的代码和数据到内存中。
- 应用程序在启动过程中，可能会加载一些共享库文件，共享库文件包含了应用程序所需的一些通用功能和代码。应用程序会根据自身的逻辑和需求，进行初始化操作，如打开文件、连接数据库、初始化网络连接等。
- 应用程序初始化完成后，会进入主循环，等待用户输入或系统事件，如鼠标点击、键盘输入等。当接收到用户输入或系统事件时，应用程序会根据相应的处理逻辑进行处理，并更新界面或执行相应的操作。



以上是 Linux 程序启动过程的一般步骤，不同的 Linux 发行版和应用程序可能会有一些差异。



















## 产生死锁的四个必要条件：

（1） 互斥条件：一个资源每次只能被一个进程使用。

（2） 占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

（3）不可强行占有:进程已获得的资源，在末使用完之前，不能强行剥夺。

（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之

一不满足，就不会发生死锁。









## 处理死锁的基本方法：

****\*死锁预防\****：通过设置某些限制条件，去破坏死锁的四个条件中的一个或几个条件，来预防发生死锁。但由于所施加的限制条件往往太严格，因而导致系统资源利用率和系统吞吐量降低。

****\*死锁避免\****：允许前三个必要条件，但通过明智的选择，确保永远不会到达死锁点，因此死锁避免比死锁预防允许更多的并发。

****\*死锁检测\****：不须实现采取任何限制性措施，而是允许系统在运行过程发生死锁，但可通过系统设置的检测机构及时检测出死锁的发生，并精确地确定于死锁相关的进程和资源，然后采取适当的措施，从系统中将已发生的死锁清除掉。

****\*死锁解除\****：与死锁检测相配套的一种措施。当检测到系统中已发生死锁，需将进程从死锁状态中解脱出来。常用方法：撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程。死锁检测盒解除有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。



















## 线程进程的区别体现在几个方面

1.因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，系统开销比较大，而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，切换速度也比进程快，效率高，但是正由于进程之间独立的特点，使得进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。

2.体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。。

3.属于同一个进程的所有线程共享该进程的所有资源，包括文件描述符。而不同过的进程相互独立。

4.线程必定也只能属于一个进程，而进程可以拥有多个线程而且至少拥有一个线程；

 

进程与线程的选择取决以下几点

1、需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的。

2、线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应

3、因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程；

4、并行操作时使用线程，如C/S[架构](http://lib.csdn.net/base/architecture)的服务器端并发线程响应用户的请求；

5、需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。

























面试总结_C++语言



C++语言

static作用是什么？在C和C++中有何区别？

· static可以修饰局部变量（静态局部变量）、全局变量（静态全局变量）和函数，被修饰的变量存储位置在静态区。对于静态局部变量，相对于一般局部变量其生命周期长，直到程序运行结束而非函数调用结束，且只在第一次被调用时定义；对于静态全局变量，相对于全局变量其可见范围被缩小，只能在本文件中可见；修饰函数时作用和修饰全局变量相同，都是为了限定访问域。

· C++的static除了上述两种用途，还可以修饰类成员（静态成员变量和静态成员函数），静态成员变量和静态成员函数不属于任何一个对象，是所有类实例所共有。

· static的数据记忆性可以满足函数在不同调用期的通信，也可以满足同一个类的多个实例间的通信。

· 未初始化时，static变量默认值为0。

指针和引用区别？

· 引用只是别名，不占用具体存储空间，只有声明没有定义；指针时具体变量，需要占用存储空间。

· 引用在声明时必须初始化为另一变量；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。

· 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。

· 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。

宏定义和内联函数(inline)区别？

· 在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。

· 内联函数本身是函数，强调函数特性，具有重载等功能。

· 内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。

















# 六、总结

以上就是今天要讲的内容，本文仅仅简单介绍了lwIP的官网主页，后续会有更多内容。



# 七、参考资料

版权声明：本文参考了其他资料和CSDN博主的文章，遵循CC 4.0 BY-SA版权协议，现附上原文出处链接及本声明。
一、 https://blog.csdn.net/as480133937/article/details/123740365
二、 https://blog.csdn.net/weibo1230123/article/details/80210097
三、 LwIP应用开发实战指南：基于STM32























---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
