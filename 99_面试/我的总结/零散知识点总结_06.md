* 👋 Hi, I’m liubo
* 👀 I’m interested in harmony
* 🌱 I’m currently learning harmony
* 💞️ I’m looking to collaborate on ...
* 📫 How to reach me ...
* 📇 sssssdsdsdsdsdsdasd
* 🎃 dsdsdsdsdsddfsgdgasd
* 🍺 jyukyuiyuiyuigkasd
* 🍥 fsdfgdsgsdgdgadsa
* ✨ xcvxcvxcvxcvdasdaasd
* 🍰 dazdsxasxsaxsaasdsa
* 🚨 gdfgdshdfhfhygjtyu





## 虚函数

## 1.虚函数与纯虚函数

· 虚函数：

o virtual 返回值类型 函数名（参数列表）{ }

o 在基类中冠以virtual的成员函数，它提供了一个接口界面。允许在派生类中对基类的虚函数重新定义

o 使用虚函数有一定的空间开销，当类中有虚函数时，编译器会为该类构造一个虚函数表

o 虚函数表是一个指针数组用来存放每个虚函数的入口地址

· 纯虚函数

o virtual 返回值类型 函数名（参数列表）= 0；

o 在基类中为其派生类保留一个函数的名字，以便派生类根据需要对他进行定义

o 作为接口存在，纯虚函数不具备函数的功能，一般不能直接被调用。

o 从基类继承来的纯虚函数，在派生类仍然是虚函数。













### 2.抽象类

· 如果一个类中至少有一个纯虚函数，那么这个类被称为抽象类（abstract class）

· 抽象类中不仅包括纯虚函数，也可包括虚函数。

· 抽象类必须用作派生其他类的基类。且不能直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态性。

· 特点

o 无法实例化对象

o 子类必须重写抽象类中的纯虚函数，否则也属于抽象类













### 3.虚析构与纯虚析构

· 多态使用时，若子类有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码，此时将父类中的析构函数改为虚析构或者纯虚析构即可

· 总结

o 解决通过父类指针释放子类对象

o 子类中没有堆区数据，可不写为虚析构或纯虚析构

o 拥有纯虚析构的类也称为抽象类







### 4.多态类中的虚函数表是compile-Time建立的还是Run-Time建立的

虚拟函数表是在编译时期就建立了，各个虚函数这时候已经被组织成一个虚拟函数的入口地址的数组。而对象的隐藏成员----虚函数表指针是在运行期间，也就是构造函数被调用时进行初始化的，这是实现多态的关键















### 5.析构函数可为virtual型，构造函数不能，为什么？

虚函数采用一种虚调用的方法，虚调用是一种可以在只有部分信息的情况下工作的机制，特别允许我们调用一个只知道接口而不知道其准确对象类型的函数，但是如果要创建一个对象，势必要知道对象的准确类型，因此构造函数不能为虚











### 6.能否把每个函数都声明为虚函数？

不能，虚函数是有代价的：由于每个虚函数的对象都必须维护一个v表，因此在使用虚函数的时候都会产生一个系统开销。如果仅是一个很小的类，且不想派生其他类，那么根本没必要使用虚函数















## 7.隐藏、重载与重写

· 重写/覆盖（override）：函数返回值类型，函数名，参数列表完全一致称为重写

· 重载(overload)：同一作用域下函数名相同，参数类型、个数、顺序不同

o 函数的返回值不可以做重载的条件
（1）重写和重载主要有以下几点不同。

· 范围的区别：被重写的和重写的函数在两个类中，而重载和被重载的函数在同一个类中。

· 参数的区别：被重写函数和重写函数的参数列表一定相同，而被重载函数和重载函数的参数列表一 定不同。

· virtual 的区别：重写的基类中被重写的函数必须要有virtual 修饰，而重载函数和被重载函数可以被 virtual
修饰，也可以没有。

（2）隐藏和重写、重载有以下几点不同 。

· 与重载的范围不同：和重写一样，隐藏函数和被隐藏函数不在同一个类中。

· 参数的区别：隐藏函数和被隐藏的函数的参数列表可以相同，也可不同，但是函数名肯定要相同。 当参数不相同时，无论基类中的参数是否被virtual 修饰，基类的函数都是被隐藏，而不是被重写。

注意：虽然重载和覆盖都是实现多态的基础，但是两者实现的技术完全不相同 ，达到的目的也是完全不同的，覆盖是动态态绑定的多态 ，而重载是静态绑定的多态 。
图片参考链接：https://blog.csdn.net/qq_37934101/article/details/81365449







## 8.友元

· 友元是定义在类外部的普通函数

· 需要在类体内进行说明，需加上关键字friend

· 友元不是成员函数，但是它可以访问类中的私有成员

· 作用在于提高程序运行效率，但是破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员

· 友元可以是一个函数（全局函数、成员函数），被称为友元函数；可用是一个类，被称为友元类

















### 9.C语言中的NULL

· C语言中的NULL通常被定义为：#define NULL ((void *)0)

· NULL实际上是一个空指针，C语言中把空指针赋给int和char指针的时候，发生了隐式类型转换，把void指针转换成了相应类型的指针。

### C++中的NULL

C++是强类型语言，void*是不能隐式转换成其他类型的指针的，所以实际上编译器提供的头文件做了相应的处理：

\#ifdef __cplusplus

\#define NULL 0

\#else

\#define NULL ((void *)0)

\#endif

· 1

· 2

· 3

· 4

· 5

实际上，用NULL代替0表示空指针在函数重载时会出现问题；

void func(void* i);**//func(nullptr)**

void func(int i);**//func(NULL)**

· 1

· 2









### 10.C++中的nullptr

· nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。

· nullptr的l另一种实现方式如下：

\#include <iostream>

using namespace std;

 

void func(void* i)

{

​	cout << "func1" << endl;

}

 

void func(int i)

{

​	cout << "func2" << endl;

}

 

void main(int argc,char* argv[])

{

​	func(NULL);

​	func(nullptr);

​	getchar();

}



























# 六、总结

以上就是今天要讲的内容，本文仅仅简单介绍了lwIP的官网主页，后续会有更多内容。



# 七、参考资料

版权声明：本文参考了其他资料和CSDN博主的文章，遵循CC 4.0 BY-SA版权协议，现附上原文出处链接及本声明。
一、 https://blog.csdn.net/as480133937/article/details/123740365
二、 https://blog.csdn.net/weibo1230123/article/details/80210097
三、 LwIP应用开发实战指南：基于STM32









---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
