* 👋 Hi, I’m liubo
* 👀 I’m interested in harmony
* 🌱 I’m currently learning harmony
* 💞️ I’m looking to collaborate on ...
* 📫 How to reach me ...
* 📇 sssssdsdsdsdsdsdasd
* 🎃 dsdsdsdsdsddfsgdgasd
* 🍺 jyukyuiyuiyuigkasd
* 🍥 fsdfgdsgsdgdgadsa
* ✨ xcvxcvxcvxcvdasdaasd
* 🍰 dazdsxasxsaxsaasdsa
* 🚨 gdfgdshdfhfhygjtyu


> # Ctitle\_01_介绍

















## 1.宏，内联函数

### 内联函数

· 定义：在函数定义体前加入关键字inline,使函数成为内联函数

· 增加空间消耗换取效率提高，这点与宏一样

· 内联函数和普通函数相比可以加快程序运行的速度，因为不需要中断调用

```c++
void fun(int x,int y);
inline void fun(int x,int y){**//必须放在定义体前面，不能放在声明前面**
	...
}

```

· 适用情况

o 一个函数不断被重复调用

o 函数只有简单几行，且函数内不包括for、while、switch语句

### 内联函数与宏的差别

· 内联函数要做类型检查，而宏不需要

· 宏是在代码处不加任何验证的简单替代，而内联函数是将代码直接插入到调用处，而减少了普通函数调用时的资源消耗





### 2.写一个 “标准”宏MIN

\#define min(a,b) ( (a)<=(b) ? (a):(b) )





### 3.typedef和define有什么区别

· 用法不同：typedef 用来定义一种数据类型的别名，增强程序的可读性。define主要用来定义常量，以及书写复杂使用频繁的宏。

· 执行时间不同：typedef 是编译过程的一部分，有类型检查的功能。define 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。

· 作用域不同：typedef 有作用域限定。define 不受作用域约束，只要是在define 声明后的引用 都是正确的。

· 对指针的操作不同：typedef 和define 定义的指针时有很大的区别。
注意：typedef 定义是语句， 因为句尾要加上分号。 而define不是语句，千万不
能在句尾加分号









### 4.指针常量和常量指针

[指针常量和常量指针](https://blog.csdn.net/weixin_44515978/article/details/117768882)





常量指针：const修饰的是指针，指针指向可以改变，但是指针指向的值不能改变

常量指针,指向常量的指针





指针常量：修饰的是常量，指针指向不可改变，但是在指针指向的值可以改变

指针常量，指针本身是常量











### 5.指针函数和函数指针

[指针函数和函数指针](https://blog.csdn.net/weixin_44515978/article/details/117769753)











### 6.指针数组数组指针

· 指针数组：int *a[10];

o 是一个数组，a[ ]里面存的是地址

· 数组指针：int (*a)[10];

o 是一个指针，指向整个数组















### 7.函数传参

函数传参的三种方式：值传递，地址传递，引用传递

**//值传递:就是函数调用时实参将数值传入给形参**

**//值传递时，如果形参发生，并不会影响实参**

void swap01(int a,int b){

​	int temp = a;

​	a = b;

​	b = temp;

}

**//地址传递：利用指针作函数参数，可以修改实参的值**

void swap02(int* a,int* b){

​	int temp = *a;

​	*a = *b;

​	*b = temp;

}

**//引用传递**

**//通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单**

void swap03(int& a;int& b){

​	int temp = a;

​	a = b;

​	b = temp;

}













### 8.一些定义

| ***\*定义\****     | ***\*说明\****                                               |
| ------------------ | ------------------------------------------------------------ |
| int a;             | 一个整型数                                                   |
| int *a;            | 一个指向整型的指针                                           |
| int **a;           | 一个指向指针的指针，它指向的指针是一个整数类型               |
| int a[10];         | 一个有10个整型的数组                                         |
| int *a[10];        | 指针数组：一个有10个指针的数组，指针指向整型                 |
| int (*a)[10];      | 数组指针：一个指向有10个整型数数组的指针                     |
| int (*a)(int);     | 函数指针：一个指向函数的指针，该函数有一个整型参数，并返回一个整型 |
| int (*a[10])(int); | 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型 |













### 9.指针与引用的区别

· 指针有自己的一块空间，而引用只是一个别名,所以不能创建引用的引用，引用必须初始化，而指针可用为空；

· 使用sizeof看一个指针的大小是4，而引用的大小则是被引用对象的大小；

· 指针和引用使用++运算符的意义不一样；引用自增自减时，是引用所代表的空间的值发生变化，而指针自增自减时是指针指向的位置发生变化

· 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；

· 可以有const指针，但是没有const引用；

· 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；

· 指针可以有多级指针（**p），而引用止于一级；

· 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。

· 引用本身不是一种数据类型，因此引用本身并不占存储单元，系统也不给引用分配存储单元，不能建立数组的引用













### 10.this指针

· this指针本质上是一个函数参数，只是编译器隐藏起形式的，语法层面上的参数

· this ***\*只能在成员函数中使用\****，全局函数和静态函数(属于类，不属于对象)都不能使用this

**·** ***\*this 在成员函数的开始前构造，在成员的结束后清除\****。调用类成员函数时，编译器将类的指针作为参数传递进去

· 用途：

o 当形参与成员变量同名时，可以用this指针来区分

o 在类的非静态成员函数中返回对象本身，可用return *this；

class A{

​	public:

​	int func(int p){} **//相当于 int func(A\* const this,int p)**

};

A a;

a.func(10);**//相当于 A::func(&a,10);**

· 1

· 2

· 3

· 4

· 5

· 6

**·** ***\*this 指针并不占用对象空间\****，所以成员函数的参数，不管是不是隐含的，都不会占用对象空间，只会占用参数传递时的栈空间，或者直接占用一个寄存器

· this 会因编译器不同而有不同的存放位置，可能是堆、栈、也可能是寄存器

**·** ***\*this 指针只有在成员函数中才有定义，不能通过对象使用this指针\****，无法知道一个对象的this指针位置（只有在成员函数里才有this指针的位置，可通过&this获取）











# 六、总结

以上就是今天要讲的内容，本文仅仅简单介绍了lwIP的官网主页，后续会有更多内容。



# 七、参考资料

版权声明：本文参考了其他资料和CSDN博主的文章，遵循CC 4.0 BY-SA版权协议，现附上原文出处链接及本声明。
一、 https://blog.csdn.net/as480133937/article/details/123740365
二、 https://blog.csdn.net/weibo1230123/article/details/80210097
三、 LwIP应用开发实战指南：基于STM32









---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
