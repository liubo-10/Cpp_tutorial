* 👋 Hi, I’m liubo
* 👀 I’m interested in harmony
* 🌱 I’m currently learning harmony
* 💞️ I’m looking to collaborate on ...
* 📫 How to reach me ...
* 📇 sssssdsdsdsdsdsdasd
* 🎃 dsdsdsdsdsddfsgdgasd
* 🍺 jyukyuiyuiyuigkasd
* 🍥 fsdfgdsgsdgdgadsa
* ✨ xcvxcvxcvxcvdasdaasd
* 🍰 dazdsxasxsaxsaasdsa
* 🚨 gdfgdshdfhfhygjtyu


> # Ctitle\_01_介绍















### 1.指针和句柄

· 句柄和指针其实是两个截然不同的概念，window系统用句柄标记系统资源，隐藏系统的信息，它是一个32bit的整数

· 而指针则标记某个物理内存地址，两者概念不同











### 2.如何避免“野指针”

· 指针变量声明时没有被初始化。解决办法：指针声明时初始化，可以是具体的地址值，也可让它指向NULL。

· 指针p被free或者delete之后，没有置为NULL。解决办法：指针指向的内存空间被释放后指针应该指向NULL。

· 指针操作超越了变量的作用范围。解决办法：在变量的作用域结束前释放掉变量的地址空间并且让指针指向NULL。

















### 3.空指针与迷途指针区别

· 当delete一个指针的时候，实际上仅仅是让编译器释放内存，但指针本身依然存在，此时他就是一个迷途指针

· 可令ptr = 0; 使迷途指针变为空指针











## 4.const

· 任何不会修改数据成员的函数都应该声明为const 类型

· 在参数中使用const应该使用引用或指针，而不是一般的对象实例

· 除了重载操作符外一般不要将返回值类型定为对某个对象的const引用











### 5.const 使用

**·** ***\*const使用：定义常量、修饰函数参数、修饰函数返回值\****

· const 修饰类的成员变量，表示成员变量，不能被修改

· 如果const构成函数重载，const对象只能调用const函数，非const对象优先调用非const函数

· const 函数只能调用const函数，非const函数可以调用const函数

· 类体外定义的const成员函数，在定义和声明处都需要const修饰符







### 6.const 作用

| ***\*作用\****                     | ***\*说明\****                                               |
| ---------------------------------- | ------------------------------------------------------------ |
| 可以定义const常量                  |                                                              |
| 便于进行类型检查                   | const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且在字符替换时可能会产生意料不到的错误 |
| 可以保护被修饰的东西               | 防止意外的修改，增强程序的健壮性。                           |
| 可以很方便地进行参数的调整和修改   | 同宏定义一样，可以做到不变则已，一变都变                     |
| 为函数重载提供了一个参考           | void f(int i) {…} //一个函数 void f(int i) const {…} //上一个函数的重载 |
| 可以节省空间，避免不必要的内存分配 | const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝 |
| 提高了效率                         | 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高 |

参考链接：https://blog.csdn.net/moli152_/article/details/45100717











### 7.如何修改const成员函数

用mutable修饰成员变量名后，就可以修改类成员变量











### 8.将Const类型转化为非Const类型

采用const_cast 进行转换。
用法：const_cast <type_id> (expression)













## 7.sizeof

数据对齐原则：是指数据所在的内存地址必须是该数据长度的整数倍。

















### 8.sizeof和strlen的区别

· sizeof是一个操作符，strlen是库函数。

· sizeof的参数可以是数据的类型，也可以是变量、函数；而strlen只能用char*做参数且且以结尾为‘\0’的字符串。

· 编译器在编译时就计算出了sizeof的结果，而strlen函数必须在运行时才能计算出来。并且sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度。

· 数组做sizeof的参数不退化，传递给strlen就退化为指针了

· sizeof不能返回被动态分配的数组或外部的数组的尺寸

· sizeof不能作用于函数类型，不完全类型或位字段，不完全类型是指具有未知存储大小数据的类型，如未知存储大小的数组类型、未知内容的结构或联合类型、void类型等







### 9.sizeof的使用场合

· 其中一个主要用途就是与存储分配和I/O系统那样的例程通信

· 可以查看某种类型的对象在内存中所占的单元字节

· 在动态分配一个对象时，可以让系统知道要分配多少内存

· 便于一些类型的扩充。在window中有很多结构类型就有一个专用的字段来存放该类型的字节大小

· 如果操作数是函数中的数组形参或函数类型的形参，sizeof给出其指针的大小











## 10.强制类型转换运算符

***\*static_cast\****

· 用于非多态类型的转换

· 不执行运行时类型检查（转换安全性不如 dynamic_cast）

· 通常用于转换数值数据类型（如 float -> int）

· 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）

· 用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知

***\*dynamic_cast\****

· 用于多态类型的转换，只能用于含有虚函数的类

· 执行行运行时类型检查

· 只适用于指针或引用

· 对不明确的指针的转换将失败（返回 nullptr），但不引发异常

· 可以在整个类层次结构中移动指针，包括向上转换、向下转换

***\*const_cast\****

· 用于将const变量转为非const

· 用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ） reinterpret_cast

· 用于位的简单重新解释

· 滥用 reinterpret_cast 运算符可能很容易带来风险。除非所需转换本身是低级别的，否则应- 使用其他强制转换运算符之一。

· 允许将任何指针转换为任何其他指针类型（如 char* 到 int* 或 One_class* 到 Unrelated_class* 之类的转换，但其本身并不安全）

· 也允许将任何整数类型转换为任何指针类型以及反向转换。

· reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。

· reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。

***\*bad_cast\****

· 由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常

try {

​	Circle& ref_circle = dynamic_cast<Circle&>(ref_shape);

}

catch (bad_cast b) {

​	cout << "Caught: " << b.what();

}

· 1

· 2

· 3

· 4

· 5

· 6

***\*为什么不使用C的强制转换？\****
C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。









































# 六、总结

以上就是今天要讲的内容，本文仅仅简单介绍了lwIP的官网主页，后续会有更多内容。



# 七、参考资料

版权声明：本文参考了其他资料和CSDN博主的文章，遵循CC 4.0 BY-SA版权协议，现附上原文出处链接及本声明。
一、 https://blog.csdn.net/as480133937/article/details/123740365
二、 https://blog.csdn.net/weibo1230123/article/details/80210097
三、 LwIP应用开发实战指南：基于STM32









---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
